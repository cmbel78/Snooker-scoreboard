<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Snooker Scoreboard</title>
  <style>
    :root{
      --bg:#000; --fg:#fff; --muted:#9aa0a6; --accent:#fff;
      --panel:#111; --panel2:#0b0b0b; --outline:#fff;
      --btnSize:150px; /* bigger ball button size for touch */
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif;-webkit-text-size-adjust:100%}
    body{touch-action:manipulation}
    button{-webkit-tap-highlight-color: transparent}
    .app{display:flex;flex-direction:column;height:100%;max-width:1400px;margin:0 auto}

    /* Top: 50/50 player panels */
    .players{display:grid;grid-template-columns:1fr 1fr;gap:14px;padding:14px}
    .player{background:linear-gradient(180deg,var(--panel),var(--panel2));border-radius:16px;padding:18px;position:relative;min-height:170px}
    .player .name{font-size:clamp(18px,3.5vw,28px);font-weight:700;opacity:.95;cursor:pointer;display:inline-block}
    .score{font-size:clamp(56px,9vw,108px);line-height:1;margin:10px 0 4px;font-weight:800;letter-spacing:1px}
    .selected .score{outline:3px solid var(--outline);outline-offset:6px;border-radius:12px;padding:6px 10px}
    .meta{display:flex;gap:18px;flex-wrap:wrap;color:var(--muted);font-size:clamp(12px,2.2vw,15px)}
    .meta div strong{color:var(--fg)}

    /* Middle bar */
    .middle{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;gap:14px;padding:8px 14px}
    .statCard{background:#121212;border:1px solid #222;border-radius:12px;padding:14px;text-align:center}
    .statCard h3{margin:0 0 6px;font-size:14px;color:var(--muted)}
    .statCard .big{font-size:clamp(22px,4.5vw,44px);font-weight:800}

    .controls{display:flex;align-items:center;gap:12px}
    .chip{background:#121212;border:1px solid #2a2a2a;border-radius:999px;padding:8px 12px;font-size:15px}
    .chip button{background:transparent;border:1px solid #2a2a2a;color:var(--fg);padding:4px 10px;border-radius:10px;margin:0 6px;cursor:pointer;font-size:16px}

    .undoBtn,.resetBtn{justify-self:center;background:#1e1e1e;border:1px solid #333;color:#eee;padding:14px 18px;border-radius:12px;cursor:pointer;font-weight:800;font-size:16px}
    .undoBtn:active,.resetBtn:active{transform:translateY(1px)}
    .btnRow{display:flex;gap:10px;justify-content:center}

    /* Pending tray */
    .pending{display:flex;justify-content:center;align-items:center;gap:12px;padding:6px 12px;color:#ccc}
    .pending .amount{font-size:clamp(18px,3.8vw,28px);font-weight:800}
    .pending button{background:#1f1f1f;border:1px solid #333;color:#eee;border-radius:10px;padding:8px 12px;cursor:pointer}

    /* Bottom: ball buttons row */
    .bottom{margin-top:auto;padding:14px}
    .ballRow{display:grid;grid-template-columns:repeat(8,1fr);gap:12px;align-items:center}
    .ball{width:var(--btnSize);height:var(--btnSize);border-radius:50%;border:3px solid #333;display:flex;align-items:center;justify-content:center;margin:0 auto;font-weight:900;font-size:24px;cursor:pointer;box-shadow:0 2px 0 rgba(255,255,255,0.06) inset;color:#d0d0d0}
    .ball:active{transform:translateY(1px)}

    /* ball colours */
    .red{background:#b40000}
    .yellow{background:#ffd400}
    .green{background:#177a2f}
    .brown{background:#6b4423}
    .blue{background:#0f5db3}
    .pink{background:#ff5fa2}
    .black{background:#111; border-color:#666}

    .submit{grid-column:8 / 9; background:#0a84ff; color:#fff; border:none; border-radius:12px; padding:18px 12px; font-weight:800; cursor:pointer;font-size:16px}
    .submit:active{transform:translateY(1px)}

    /* Responsive tweaks */
    @media (max-width: 920px){
      :root{ --btnSize:84px }
    }
    @media (max-width: 760px){
      :root{ --btnSize:72px }
    }
  </style>

  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <meta name="theme-color" content="#000000">

</head>
<body>
  <div class="app" id="app">
    <div class="players">
      <div class="player" id="p1">
        <div class="name" data-player="1" contenteditable="true" spellcheck="false">Player 1</div>
        <div class="score" id="score1">0</div>
        <div class="meta">
          <div>High break: <strong id="hb1">0</strong></div>
          <div>Current break: <strong id="cb1">0</strong></div>
        </div>
      </div>
      <div class="player" id="p2">
        <div class="name" data-player="2" contenteditable="true" spellcheck="false">Player 2</div>
        <div class="score" id="score2">0</div>
        <div class="meta">
          <div>High break: <strong id="hb2">0</strong></div>
          <div>Current break: <strong id="cb2">0</strong></div>
        </div>
      </div>
    </div>

    <div class="middle">
      <div class="statCard">
        <h3>Points Left</h3>
        <div class="big" id="pointsLeft">147</div>
        <div class="controls" style="justify-content:center;margin-top:6px">
          <span class="chip">Reds left:
            <button id="redsMinus" aria-label="Decrease reds">âˆ’</button>
            <strong id="redsLeft">15</strong>
            <button id="redsPlus" aria-label="Increase reds">+</button>
          </span>
        </div>
      </div>

      <div class="btnRow">
        <button class="undoBtn" id="undoBtn">âŸ² Undo last score</button>
        <button class="resetBtn" id="resetBtn">ðŸ†• New Game</button>
        <button class="resetBtn" id="fsBtn">â›¶ Fullscreen</button>
      </div>

      <div class="statCard">
        <h3>Score Difference</h3>
        <div class="big" id="scoreDiff">0</div>
        <div class="controls" style="justify-content:center;margin-top:6px">
          <span class="chip">Leader: <strong id="leader">â€”</strong></span>
        </div>
      </div>
    </div>

    <div class="pending" id="pendingTray" hidden>
      Pending for <strong id="pendingPlayer">P1</strong>: <span class="amount" id="pendingAmount">0</span>
      <button id="clearPending">Clear</button>
    </div>

    <div class="bottom">
      <div class="ballRow">
        <button class="ball red" data-points="1" aria-label="Red 1">1</button>
        <button class="ball yellow" data-points="2" aria-label="Yellow 2">2</button>
        <button class="ball green" data-points="3" aria-label="Green 3">3</button>
        <button class="ball brown" data-points="4" aria-label="Brown 4">4</button>
        <button class="ball blue" data-points="5" aria-label="Blue 5">5</button>
        <button class="ball pink" data-points="6" aria-label="Pink 6">6</button>
        <button class="ball black" data-points="7" aria-label="Black 7">7</button>
        <button class="submit" id="submitBtn">Submit</button>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const qs = s=>document.querySelector(s);
      const qsa = s=>Array.from(document.querySelectorAll(s));
      const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
      const sum = arr => arr.reduce((a,b)=>a+b,0);

      const ALL_COLORS = [2,3,4,5,6,7]; // yellow..black for clearance phase
      const getBallBtn = (v)=>document.querySelector(`.ball[data-points="${v}"]`);
      function renderBallVisibility(){
        // Red visible only while reds remain
        const redBtn = getBallBtn(1);
        if (redBtn) redBtn.style.display = state.redsLeft > 0 ? '' : 'none';
        // Colors: before clearance show all; in clearance hide ones already potted
        ALL_COLORS.forEach(v=>{
          const btn = getBallBtn(v);
          if (!btn) return;
          if (state.redsLeft > 0) {
            btn.style.display = '';
          } else {
            btn.style.display = state.colorsRemaining.includes(v) ? '' : 'none';
          }
        });
      }

      const state = {
        selected: 1,
        scores: {1:0, 2:0},
        currentBreak: {1:0, 2:0},
        highBreak: {1:0, 2:0},
        pending: 0,
        pendingBalls: [], // list of point values clicked before submit
        pendingFor: 1,
        redsLeft: 15,
        colorsRemaining: [...ALL_COLORS], // used when redsLeft == 0
        history: [] // stack of {player, amount, redsDelta, colorsRemoved: []}
      };

      // Load from localStorage if available
      const saved = JSON.parse(localStorage.getItem('snookerBoardV1')||'null');
      if(saved){
        Object.assign(state, saved);
        // Backfill colorsRemaining if missing
        if(!Array.isArray(state.colorsRemaining)){
          state.colorsRemaining = [...ALL_COLORS];
        }
        qs('#score1').textContent = state.scores[1];
        qs('#score2').textContent = state.scores[2];
        qs('#cb1').textContent = state.currentBreak[1];
        qs('#cb2').textContent = state.currentBreak[2];
        qs('#hb1').textContent = state.highBreak[1];
        qs('#hb2').textContent = state.highBreak[2];
        qs('#redsLeft').textContent = state.redsLeft;
        updatePointsLeft();
      }

      // Names
      qsa('.name').forEach(el=>{
        const savedName = localStorage.getItem('snookerName'+el.dataset.player);
        if(savedName) el.textContent = savedName;
        el.addEventListener('input',()=>{
          localStorage.setItem('snookerName'+el.dataset.player, el.textContent.trim());
          updatePendingLabel();
        });
        el.addEventListener('click', ()=>selectPlayer(Number(el.dataset.player)));
      });

      function selectPlayer(p){
        if(state.selected!==p){
          // switching player ends the other player's break
          finalizeBreak(state.selected);
        }
        state.selected = p;
        state.pendingFor = p;
        updateSelectionUI();
        updatePendingLabel();
        save();
        renderBallVisibility();
      }

      function updateSelectionUI(){
        qs('#p1').classList.toggle('selected', state.selected===1);
        qs('#p2').classList.toggle('selected', state.selected===2);
      }

      function addPending(points){
        if(state.pending===0){
          state.pendingFor = state.selected; // lock pending to current selected
        }
        state.pending += points;
        state.pendingBalls.push(points);
        showPending();
      }

      function showPending(){
        qs('#pendingTray').hidden = state.pending<=0;
        qs('#pendingAmount').textContent = state.pending;
        updatePendingLabel();
      }

      function clearPending(){
        state.pending = 0;
        state.pendingBalls = [];
        qs('#pendingAmount').textContent = 0;
        qs('#pendingTray').hidden = true;
      }

      function submitPending(){
        if(state.pending<=0) return;
        const p = state.pendingFor;

        // --- simulate the pending sequence with proper post-red respot logic ---
        const colorsRemoved = [];
        const redsBefore = state.redsLeft;
        let redsSim = redsBefore;
        let colorsSim = [...state.colorsRemaining];
        let afterRed = false; // true means the very next color is respotted

        state.pendingBalls.forEach(v=>{
          if(v===1){
            if(redsSim>0) redsSim--; // pot a red
            afterRed = true;         // next color (if any) is respotted
          } else if (ALL_COLORS.includes(v)){
            if(afterRed){
              // color immediately after a red is ALWAYS respotted
              afterRed = false;
            } else if (redsSim===0){
              // in clearance phase: color stays off table
              const idx = colorsSim.indexOf(v);
              if(idx!==-1){
                colorsSim.splice(idx,1);
                colorsRemoved.push(v);
              }
            } // else (redsSim>0 and not afterRed): treat as respotted / no change
          }
        });

        const redsDelta = redsSim - redsBefore; // usually negative or 0

        // Update scores & breaks
        state.scores[p] += state.pending;
        state.currentBreak[p] += state.pending;
        if(state.currentBreak[p] > state.highBreak[p]){
          state.highBreak[p] = state.currentBreak[p];
        }

        // If we just finished the last red during this submit, reset the clearance set
        if(redsBefore>0 && redsSim===0){
          colorsSim = [...ALL_COLORS];
          // Re-run only the portion of pending after the last red to remove clearance colors actually taken
          afterRed = true; // because immediately after that final red a color is respotted
          // Walk again from the point reds hit zero
          let tempReds = redsBefore;
          for(const v of state.pendingBalls){
            if(v===1){
              if(tempReds>0){ tempReds--; afterRed = true; }
              continue;
            }
            if(tempReds>0){
              // still in reds phase, respotted
              continue;
            }
            // tempReds==0 from here on
            if(ALL_COLORS.includes(v)){
              if(afterRed){
                afterRed = false; // this post-red color is respotted
              } else {
                const idx = colorsSim.indexOf(v);
                if(idx!==-1){ colorsSim.splice(idx,1); colorsRemoved.push(v); }
              }
            }
          }
        }

        // Commit simulated table state
        state.redsLeft = clamp(redsSim,0,15);
        qs('#redsLeft').textContent = state.redsLeft;
        state.colorsRemaining = colorsSim;

        // History for undo
        state.history.push({player:p, amount: state.pending, redsDelta, colorsRemoved});

        clearPending();
        renderScores();
        updateDiff();
        updatePointsLeft();
        save();
        renderBallVisibility();
      }

      function undo(){
        const last = state.history.pop();
        if(!last) return;
        const {player, amount, redsDelta=0, colorsRemoved=[]} = last;
        state.scores[player] = Math.max(0, state.scores[player]-amount);
        state.currentBreak[player] = Math.max(0, state.currentBreak[player]-amount);
        // restore reds if we previously auto-decremented them
        state.redsLeft = clamp(state.redsLeft - (redsDelta||0), 0, 15);
        qs('#redsLeft').textContent = state.redsLeft;
        // restore any colors that were removed during clearance
        if(colorsRemoved.length){
          // Put them back (avoid duplicates)
          colorsRemoved.sort((a,b)=>a-b).forEach(v=>{
            if(!state.colorsRemaining.includes(v)) state.colorsRemaining.push(v);
          });
          // Keep colorsRemaining sorted ascending for consistency
          state.colorsRemaining.sort((a,b)=>a-b);
        }
        recomputeHighBreaks();
        renderScores();
        updateDiff();
        updatePointsLeft();
        save();
      }

      function resetGame(){
        if(!confirm('Start a new game? This will clear scores, breaks, reds, and history. Player names stay.')) return;
        Object.assign(state, {
          selected: 1,
          scores: {1:0,2:0},
          currentBreak: {1:0,2:0},
          highBreak: {1:0,2:0},
          pending: 0,
          pendingBalls: [],
          pendingFor: 1,
          redsLeft: 15,
          colorsRemaining: [...ALL_COLORS],
          history: []
        });
        clearPending();
        renderScores();
        updateDiff();
        updatePointsLeft();
        save();
        updateSelectionUI();
        renderBallVisibility();
      }

      function updateFSLabel(){
        const btn = qs('#fsBtn');
        if(!btn) return;
        const isFS = !!document.fullscreenElement;
        btn.textContent = isFS ? 'ðŸ—— Exit Fullscreen' : 'â›¶ Fullscreen';
      }

      async function toggleFullscreen(){
        try{
          if(!document.fullscreenElement){
            await document.documentElement.requestFullscreen();
          } else {
            await document.exitFullscreen();
          }
        }catch(e){
          alert('Fullscreen not available in this browser.');
        } finally {
          updateFSLabel();
        }
      }

      function finalizeBreak(player){
        if(state.currentBreak[player] > state.highBreak[player]){
          state.highBreak[player] = state.currentBreak[player];
        }
        state.currentBreak[player] = 0;
        renderScores();
      }

      function recomputeHighBreaks(){
        [1,2].forEach(p=>{
          state.highBreak[p] = Math.min(state.scores[p], Math.max(state.highBreak[p], state.currentBreak[p]));
        });
      }

      function renderScores(){
        qs('#score1').textContent = state.scores[1];
        qs('#score2').textContent = state.scores[2];
        qs('#cb1').textContent = state.currentBreak[1];
        qs('#cb2').textContent = state.currentBreak[2];
        qs('#hb1').textContent = state.highBreak[1];
        qs('#hb2').textContent = state.highBreak[2];
      }

      function updateDiff(){
        const diff = state.scores[1]-state.scores[2];
        const leader = diff===0? 'â€”' : (diff>0 ? (localStorage.getItem('snookerName1')||'Player 1') : (localStorage.getItem('snookerName2')||'Player 2'));
        qs('#scoreDiff').textContent = Math.abs(diff);
        qs('#leader').textContent = leader;
      }

      function updatePendingLabel(){
        const name = localStorage.getItem('snookerName'+state.pendingFor) || ('Player '+state.pendingFor);
        qs('#pendingPlayer').textContent = name;
      }

      function updatePointsLeft(){
        const reds = state.redsLeft;
        let points;
        if(reds>0){
          // Max possible while reds remain (assumes all blacks with reds + full color clearance)
          points = reds*8 + 27;
        } else {
          // In clearance phase, sum remaining colors
          points = sum(state.colorsRemaining);
        }
        qs('#pointsLeft').textContent = points;
      }

      function save(){
        localStorage.setItem('snookerBoardV1', JSON.stringify(state));
      }

      // Init selection
      selectPlayer(state.selected);
      renderScores();
      updateDiff();
      updatePointsLeft();
      renderBallVisibility();

      // Events
      document.addEventListener('fullscreenchange', updateFSLabel);
      qsa('.ball').forEach(btn=>btn.addEventListener('click', ()=>{
        addPending(Number(btn.dataset.points));
      }));
      qs('#submitBtn').addEventListener('click', submitPending);
      qs('#clearPending').addEventListener('click', clearPending);
      qs('#undoBtn').addEventListener('click', undo);
      qs('#resetBtn').addEventListener('click', resetGame);
      qs('#fsBtn').addEventListener('click', toggleFullscreen);
      updateFSLabel();

      // Reds adjusters (manual correction still available)
      qs('#redsMinus').addEventListener('click', ()=>{
        const was = state.redsLeft;
        state.redsLeft = clamp(state.redsLeft-1, 0, 15);
        qs('#redsLeft').textContent = state.redsLeft;
        // If we just crossed to zero by manual adjust, reset colorsRemaining to full set
        if(was>0 && state.redsLeft===0){
          state.colorsRemaining = [...ALL_COLORS];
        }
        // If we manually increased from 0 to >0, return to non-clearance phase
        if(was===0 && state.redsLeft>0){
          state.colorsRemaining = [...ALL_COLORS];
        }
        updatePointsLeft();
        save();
      });
      qs('#redsPlus').addEventListener('click', ()=>{
        const was = state.redsLeft;
        state.redsLeft = clamp(state.redsLeft+1, 0, 15);
        qs('#redsLeft').textContent = state.redsLeft;
        if(was===0 && state.redsLeft>0){
          state.colorsRemaining = [...ALL_COLORS];
        }
        updatePointsLeft();
        save();
      });

      // Click name to select handled above; also allow clicking score block
      qs('#p1').addEventListener('click', (e)=>{
        if(!e.target.classList.contains('name')) selectPlayer(1);
      });
      qs('#p2').addEventListener('click', (e)=>{
        if(!e.target.classList.contains('name')) selectPlayer(2);
      });

      // Persist selection UI
      updateSelectionUI();
    })();
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(()=>{});
      });
    }
  </script>

</body>
</html>
