<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Snooker Scoreboard</title>
  <style>
    :root{
      --bg:#000; --fg:#fff; --muted:#9aa0a6; --accent:#fff;
      --panel:#111; --panel2:#0b0b0b; --outline:#fff;
      --btnSize:150px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif;
      -webkit-text-size-adjust:100%}
    body{touch-action:manipulation}
    button{-webkit-tap-highlight-color:transparent}
    .app{display:flex;flex-direction:column;height:100%;max-width:1400px;margin:0 auto}

    /* Player panels */
    .players{display:grid;grid-template-columns:1fr 1fr;gap:14px;padding:14px}
    .player{background:linear-gradient(180deg,var(--panel),var(--panel2));
      border-radius:16px;padding:18px;position:relative;min-height:170px}
    .player .name{font-size:clamp(18px,3.5vw,28px);font-weight:700;cursor:pointer;display:inline-block}
    .score{font-size:clamp(56px,9vw,108px);line-height:1;margin:10px 0 4px;font-weight:800}
    .selected .score{outline:3px solid var(--outline);outline-offset:6px;border-radius:12px;padding:6px 10px}
    .meta{display:flex;gap:18px;flex-wrap:wrap;color:var(--muted);font-size:clamp(12px,2.2vw,15px)}
    .meta div strong{color:var(--fg)}

    /* Middle bar */
    .middle{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;gap:14px;padding:8px 14px}
    .statCard{background:#121212;border:1px solid #222;border-radius:12px;padding:14px;text-align:center}
    .statCard h3{margin:0 0 6px;font-size:14px;color:var(--muted)}
    .statCard .big{font-size:clamp(22px,4.5vw,44px);font-weight:800}

    /* >>> Compact variant just for Points Left <<< */
    .statCard.compact{padding:10px 12px}
    .statCard.compact h3{font-size:13px;margin-bottom:4px}
    .statCard.compact .big{font-size:clamp(20px,3.6vw,36px)}
    .statCard.compact .controls{gap:6px}
    .statCard.compact .chip{
      background:#151515;border:1px solid #2a2a2a;border-radius:999px;
      padding:4px 8px;font-size:13px;line-height:1;white-space:nowrap
    }
    .statCard.compact .chip button{
      background:transparent;border:1px solid #2a2a2a;color:var(--fg);
      padding:2px 8px;border-radius:8px;margin:0 6px;cursor:pointer;font-size:14px;line-height:1
    }
    .statCard.compact .chip strong{min-width:26px;display:inline-block;text-align:center}

    .btnCol{display:flex;flex-direction:column;align-items:center;gap:12px}
    .btnRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
    .undoBtn,.resetBtn{background:#1e1e1e;border:1px solid #333;color:#eee;
      padding:14px 18px;border-radius:12px;cursor:pointer;font-weight:800;font-size:16px}
    .undoBtn:active,.resetBtn:active{transform:translateY(1px)}

    /* Foul + redo row */
    .foulRow{display:flex;gap:14px;justify-content:center;flex-wrap:wrap}
    .foulBtn{
      width:48px;height:48px;border-radius:999px;border:2px solid #555;
      background:#fff;color:#000;font-weight:900;font-size:16px;cursor:pointer;
    }
    .foulBtn:active{transform:translateY(1px)}
    .redoBtn{background:#1e1e1e;border:1px solid #333;color:#eee;
      padding:14px 18px;border-radius:12px;cursor:pointer;font-weight:800;font-size:16px}
    .redoBtn:active{transform:translateY(1px)}
    .foulBadge{background:#2b2b2b;border:1px solid #3a3a3a;border-radius:999px;
      padding:4px 10px;margin-left:8px;font-size:14px;display:none}

    .controls{display:flex;align-items:center;gap:12px}
    .chip{background:#121212;border:1px solid #2a2a2a;border-radius:999px;padding:8px 12px;font-size:15px}
    .chip button{background:transparent;border:1px solid #2a2a2a;color:var(--fg);padding:4px 10px;border-radius:10px;margin:0 6px;cursor:pointer;font-size:16px}

    /* Pending tray */
    .pending{display:flex;justify-content:center;align-items:center;gap:12px;padding:6px 12px;color:#ccc}
    .pending .amount{font-size:clamp(18px,3.8vw,28px);font-weight:800}
    .pending button{background:#1f1f1f;border:1px solid #333;color:#eee;border-radius:10px;padding:8px 12px;cursor:pointer}

    /* Balls */
    .bottom{margin-top:auto;padding:14px}
    .ballRow{display:grid;grid-template-columns:repeat(8,1fr);gap:12px;align-items:center}
    .ball{width:var(--btnSize);height:var(--btnSize);border-radius:50%;border:3px solid #333;
      display:flex;align-items:center;justify-content:center;margin:0 auto;font-weight:900;
      font-size:24px;cursor:pointer;box-shadow:0 2px 0 rgba(255,255,255,0.06) inset;color:#d0d0d0}
    .ball:active{transform:translateY(1px)}
    .red{background:#b40000}.yellow{background:#ffd400}.green{background:#177a2f}
    .brown{background:#6b4423}.blue{background:#0f5db3}.pink{background:#ff5fa2}
    .black{background:#111;border-color:#666}
    .submit{grid-column:8 / 9;background:#0a84ff;color:#fff;border:none;border-radius:12px;
      padding:18px 12px;font-weight:800;cursor:pointer;font-size:16px}
    .submit:active{transform:translateY(1px)}

    @media(max-width:1100px){
      :root{--btnSize:120px}
      .undoBtn,.resetBtn,.redoBtn{padding:12px 14px;font-size:15px}
      .foulBtn{width:44px;height:44px;font-size:15px}
    }
    @media(max-width:920px){:root{--btnSize:84px}}
    @media(max-width:760px){:root{--btnSize:72px}}

    /* --- Modal: fullscreen-safe confirm (no native alert/confirm) --- */
    .modalBackdrop{
      position:fixed;inset:0;background:rgba(0,0,0,.6);
      display:none;align-items:center;justify-content:center;z-index:9999;
    }
    .modal{background:#141414;border:1px solid #2a2a2a;border-radius:14px;padding:18px;min-width:280px;max-width:90%}
    .modal h4{margin:0 0 10px;font-size:18px}
    .modal p{margin:0 0 16px;color:#ccc}
    .modal .row{display:flex;gap:10px;justify-content:flex-end}
    .btn{background:#1e1e1e;border:1px solid #333;color:#eee;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:700}
    .btn.primary{background:#0a84ff;border-color:#0a84ff}
  </style>
</head>
<body>
<audio id="tapSound" src="click.wav" preload="auto"></audio>
  <div class="app" id="app">
    <div class="players">
      <div class="player" id="p1">
        <div class="name" data-player="1" contenteditable="true" spellcheck="false">Player 1</div>
        <div class="score" id="score1">0</div>
        <div class="meta">
          <div>High break: <strong id="hb1">0</strong></div>
        </div>
      </div>
      <div class="player" id="p2">
        <div class="name" data-player="2" contenteditable="true" spellcheck="false">Player 2</div>
        <div class="score" id="score2">0</div>
        <div class="meta">
          <div>High break: <strong id="hb2">0</strong></div>
        </div>
      </div>
    </div>

    <div class="middle">
      <!-- Compact points-left card -->
      <div class="statCard compact">
        <h3>Points Left</h3>
        <div class="big" id="pointsLeft">147</div>
        <div class="controls" style="justify-content:center;margin-top:4px">
          <span class="chip">Reds left:
            <button id="redsMinus" aria-label="Decrease reds">âˆ’</button>
            <strong id="redsLeft">15</strong>
            <button id="redsPlus" aria-label="Increase reds">+</button>
          </span>
        </div>
      </div>

      <div class="btnCol">
        <div class="btnRow">
          <button class="undoBtn" id="undoBtn">âŸ² Undo</button>
          <button class="resetBtn" id="resetBtn">ðŸ†• New Game</button>
          <button class="resetBtn" id="fsBtn">â›¶ Fullscreen</button>
        </div>
        <div class="foulRow">
          <button class="foulBtn" data-foul="4">F4</button>
          <button class="foulBtn" data-foul="5">F5</button>
          <button class="foulBtn" data-foul="6">F6</button>
          <button class="foulBtn" data-foul="7">F7</button>
          <button class="redoBtn" id="redoBtn">â†» Redo</button>
        </div>
      </div>

      <div class="statCard">
        <h3>Score Difference</h3>
        <div class="big" id="scoreDiff">0</div>
        <div class="controls" style="justify-content:center;margin-top:6px">
          <span class="chip">Leader: <strong id="leader">â€”</strong></span>
        </div>
      </div>
    </div>

    <div class="pending" id="pendingTray" hidden>
      Pending for <strong id="pendingPlayer">P1</strong>:
      <span class="amount" id="pendingAmount">0</span>
      <span class="foulBadge" id="foulBadge">FOUL</span>
      <button id="clearPending">Clear</button>
    </div>

    <div class="bottom">
      <div class="ballRow">
        <button class="ball red" data-points="1" aria-label="Red 1">1</button>
        <button class="ball yellow" data-points="2" aria-label="Yellow 2">2</button>
        <button class="ball green" data-points="3" aria-label="Green 3">3</button>
        <button class="ball brown" data-points="4" aria-label="Brown 4">4</button>
        <button class="ball blue" data-points="5" aria-label="Blue 5">5</button>
        <button class="ball pink" data-points="6" aria-label="Pink 6">6</button>
        <button class="ball black" data-points="7" aria-label="Black 7">7</button>
        <button class="submit" id="submitBtn">Submit</button>
      </div>
    </div>
  </div>

  <!-- Fullscreen-safe modal -->
  <div class="modalBackdrop" id="confirmModal">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
      <h4 id="confirmTitle">Start a new game?</h4>
      <p>This will clear scores, breaks, reds, and history. Player names stay.</p>
      <div class="row">
        <button class="btn" id="cancelReset">Cancel</button>
        <button class="btn primary" id="confirmReset">Yes, reset</button>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const qs = s=>document.querySelector(s);
      const qsa = s=>Array.from(document.querySelectorAll(s));
      const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
      const sum = arr => arr.reduce((a,b)=>a+b,0);
      const ALL_COLORS = [2,3,4,5,6,7];

      const state = {
        selected: 1,
        scores: {1:0, 2:0},
        currentBreak: {1:0, 2:0},      // kept internally for high break; not shown
        highBreak: {1:0, 2:0},
        pending: 0,
        pendingBalls: [],
        pendingFor: 1,
        pendingFoul: false,
        redsLeft: 15,
        colorsRemaining: [...ALL_COLORS],
        history: [],                    // {player, amount, redsDelta, colorsRemoved: [], foul?:true}
        redoStack: []
      };
const playTap = () => {
  const el = document.getElementById('tapSound');
  if (!el) return;
  el.currentTime = 0;
  el.play().catch(()=>{});
};

document.addEventListener('click', e => {
  if (e.target.closest('button')) playTap();
});

      // Minimal restore
      const saved = JSON.parse(localStorage.getItem('snookerBoardV1')||'null');
      if(saved){
        Object.assign(state, saved);
        if(!Array.isArray(state.colorsRemaining)) state.colorsRemaining = [...ALL_COLORS];
        if(typeof state.pendingFoul!=='boolean') state.pendingFoul = false;
        renderScores(); updateDiff(); updatePointsLeft();
      }

      function save(){
        localStorage.setItem('snookerBoardV1', JSON.stringify({
          selected: state.selected,
          scores: state.scores,
          currentBreak: state.currentBreak,
          highBreak: state.highBreak,
          pending: 0, pendingBalls: [], pendingFor: state.selected, pendingFoul: false,
          redsLeft: state.redsLeft,
          colorsRemaining: state.colorsRemaining,
          history: state.history
        }));
      }

      // Selection & UI
      function selectPlayer(p){
        if(state.selected!==p){ finalizeBreak(state.selected); }
        state.selected = p;
        state.pendingFor = p;
        qs('#p1').classList.toggle('selected', p===1);
        qs('#p2').classList.toggle('selected', p===2);
        updatePendingLabel(); save(); renderBallVisibility();
      }
      function updatePendingLabel(){
        const name = localStorage.getItem('snookerName'+state.pendingFor) || ('Player '+state.pendingFor);
        qs('#pendingPlayer').textContent = name;
      }

      // Pending
      function addPending(points){
        if(state.pendingFoul) return;
        if(state.pending===0){ state.pendingFor = state.selected; }
        state.pending += points;
        state.pendingBalls.push(points);
        showPending();
      }
      function addFoul(points){
        if(state.pending===0){ state.pendingFor = state.selected; }
        state.pendingFoul = true;
        state.pending += points;
        showPending();
      }
      function showPending(){
        qs('#pendingTray').hidden = state.pending<=0;
        qs('#pendingAmount').textContent = state.pending;
        qs('#foulBadge').style.display = (state.pendingFoul && state.pending>0) ? 'inline-block' : 'none';
        updatePendingLabel();
      }
      function clearPending(){
        state.pending = 0;
        state.pendingBalls = [];
        state.pendingFoul = false;
        state.pendingFor = state.selected;
        qs('#pendingAmount').textContent = 0;
        qs('#pendingTray').hidden = true;
        qs('#foulBadge').style.display = 'none';
      }

      // Simulation for normal (non-foul) submits
      function simulatePendingSequence(){
        const redsBefore = state.redsLeft;
        let redsSim = redsBefore;
        let colorsSim = [...state.colorsRemaining];
        let afterRed = false;
        const colorsRemoved = [];

        state.pendingBalls.forEach(v=>{
          if(v===1){
            if(redsSim>0) redsSim--;
            afterRed = true;
          } else if(ALL_COLORS.includes(v)){
            if(afterRed){
              afterRed = false; // respotted
            } else if (redsSim===0){
              const idx = colorsSim.indexOf(v);
              if(idx!==-1){ colorsSim.splice(idx,1); colorsRemoved.push(v); }
            }
          }
        });

        if(redsBefore>0 && redsSim===0){
          colorsSim = [...ALL_COLORS];
          let tempReds = redsBefore, postRed = false;
          for(const v of state.pendingBalls){
            if(v===1){ if(tempReds>0){ tempReds--; postRed = true; } continue; }
            if(tempReds>0) continue;
            if(ALL_COLORS.includes(v)){
              if(postRed){ postRed = false; }
              else{
                const idx = colorsSim.indexOf(v);
                if(idx!==-1){ colorsSim.splice(idx,1); colorsRemoved.push(v); }
              }
            }
          }
        }

        const redsDelta = redsSim - redsBefore;
        return { redsDelta, colorsAfter: colorsSim, colorsRemoved };
      }

      // Submit
      function submitPending(){
        if(state.pending<=0) return;
        const p = state.pendingFor;

        if(state.pendingFoul){
          const action = { player:p, amount:state.pending, redsDelta:0, colorsRemoved:[], foul:true };
          state.scores[p] += state.pending;
          state.history.push(action);
          state.redoStack = [];
          clearPending();
          renderScores(); updateDiff(); updatePointsLeft(); renderBallVisibility(); save();
          return;
        }

        const { redsDelta, colorsAfter, colorsRemoved } = simulatePendingSequence();

        state.scores[p] += state.pending;
        state.currentBreak[p] += state.pending;
        if(state.currentBreak[p] > state.highBreak[p]) state.highBreak[p] = state.currentBreak[p];

        state.redsLeft = clamp(state.redsLeft + redsDelta, 0, 15);
        state.colorsRemaining = colorsAfter;

        const action = { player:p, amount:state.pending, redsDelta, colorsRemoved, foul:false };
        state.history.push(action);
        state.redoStack = [];

        clearPending();
        renderScores(); updateDiff(); updatePointsLeft(); renderBallVisibility(); save();
      }

      // Undo / Redo
      const deepClone = (o)=>JSON.parse(JSON.stringify(o));

      function undo(){
        const last = state.history.pop();
        if(!last) return;
        state.redoStack.push(deepClone(last));

        const { player, amount, redsDelta=0, colorsRemoved=[], foul=false } = last;
        state.scores[player] = Math.max(0, state.scores[player] - amount);

        if(!foul){
          state.currentBreak[player] = Math.max(0, state.currentBreak[player] - amount);
          state.redsLeft = clamp(state.redsLeft - redsDelta, 0, 15);
          if(colorsRemoved.length){
            colorsRemoved.forEach(v=>{
              if(!state.colorsRemaining.includes(v)) state.colorsRemaining.push(v);
            });
            state.colorsRemaining.sort((a,b)=>a-b);
          }
          recomputeHighBreaks();
        }

        renderScores(); updateDiff(); updatePointsLeft(); renderBallVisibility(); save();
      }

      function redo(){
        const last = state.redoStack.pop();
        if(!last) return;
        state.history.push(deepClone(last));

        const { player, amount, redsDelta=0, colorsRemoved=[], foul=false } = last;
        state.scores[player] += amount;

        if(!foul){
          state.currentBreak[player] += amount;
          if(state.currentBreak[player] > state.highBreak[player]) state.highBreak[player] = state.currentBreak[player];
          state.redsLeft = clamp(state.redsLeft + redsDelta, 0, 15);
          if(colorsRemoved.length){
            colorsRemoved.forEach(v=>{
              const idx = state.colorsRemaining.indexOf(v);
              if(idx!==-1) state.colorsRemaining.splice(idx,1);
            });
          }
        }

        renderScores(); updateDiff(); updatePointsLeft(); renderBallVisibility(); save();
      }

      // Ball visibility based on phase
      function getBallBtn(v){ return document.querySelector(`.ball[data-points="${v}"]`); }
      function renderBallVisibility(){
        const redBtn = getBallBtn(1);
        if(redBtn) redBtn.style.display = state.redsLeft > 0 ? '' : 'none';
        ALL_COLORS.forEach(v=>{
          const btn = getBallBtn(v); if(!btn) return;
          if (state.redsLeft > 0) btn.style.display = '';
          else btn.style.display = state.colorsRemaining.includes(v) ? '' : 'none';
        });
      }

      // Breaks & derived displays
      function finalizeBreak(player){
        if(state.currentBreak[player] > state.highBreak[player]){
          state.highBreak[player] = state.currentBreak[player];
        }
        state.currentBreak[player] = 0;
        renderScores();
      }
      function recomputeHighBreaks(){
        [1,2].forEach(p=>{
          state.highBreak[p] = Math.min(state.scores[p], Math.max(state.highBreak[p], state.currentBreak[p]));
        });
      }
      function renderScores(){
        qs('#score1').textContent = state.scores[1];
        qs('#score2').textContent = state.scores[2];
        qs('#hb1').textContent = state.highBreak[1];
        qs('#hb2').textContent = state.highBreak[2];
      }
      function updateDiff(){
        const diff = state.scores[1]-state.scores[2];
        const leader = diff===0? 'â€”' : (diff>0 ? (localStorage.getItem('snookerName1')||'Player 1') : (localStorage.getItem('snookerName2')||'Player 2'));
        qs('#scoreDiff').textContent = Math.abs(diff);
        qs('#leader').textContent = leader;
      }
      function updatePointsLeft(){
        const reds = state.redsLeft;
        const points = reds>0 ? (reds*8 + 27) : sum(state.colorsRemaining);
        qs('#pointsLeft').textContent = points;
        qs('#redsLeft').textContent = state.redsLeft;
      }

      // Names
      qsa('.name').forEach(el=>{
        const savedName = localStorage.getItem('snookerName'+el.dataset.player);
        if(savedName) el.textContent = savedName;
        el.addEventListener('input',()=>{
          localStorage.setItem('snookerName'+el.dataset.player, el.textContent.trim());
          updatePendingLabel();
        });
        el.addEventListener('click', ()=>selectPlayer(Number(el.dataset.player)));
      });

      // Reds adjusters
      qs('#redsMinus').addEventListener('click', ()=>{
        const was = state.redsLeft;
        state.redsLeft = clamp(state.redsLeft-1, 0, 15);
        if(was>0 && state.redsLeft===0) state.colorsRemaining = [...ALL_COLORS];
        if(was===0 && state.redsLeft>0) state.colorsRemaining = [...ALL_COLORS];
        updatePointsLeft(); renderBallVisibility(); save();
      });
      qs('#redsPlus').addEventListener('click', ()=>{
        const was = state.redsLeft;
        state.redsLeft = clamp(state.redsLeft+1, 0, 15);
        if(was===0 && state.redsLeft>0) state.colorsRemaining = [...ALL_COLORS];
        updatePointsLeft(); renderBallVisibility(); save();
      });

      // Fullscreen label toggle
      document.addEventListener('fullscreenchange', ()=>{
        const btn = qs('#fsBtn');
        btn.textContent = document.fullscreenElement ? 'ðŸ—— Exit Fullscreen' : 'â›¶ Fullscreen';
      });

      // Events
      qsa('.ball').forEach(btn=>btn.addEventListener('click', ()=>addPending(Number(btn.dataset.points))));
      qsa('.foulBtn').forEach(btn=>btn.addEventListener('click', ()=>addFoul(Number(btn.dataset.foul))));
      qs('#submitBtn').addEventListener('click', submitPending);
      qs('#clearPending').addEventListener('click', clearPending);
      qs('#undoBtn').addEventListener('click', undo);
      qs('#redoBtn').addEventListener('click', redo);

      // FULLSCREEN-SAFE "New Game" modal (no native confirm)
      const modal = qs('#confirmModal'), openModal=()=>modal.style.display='flex', closeModal=()=>modal.style.display='none';
      qs('#resetBtn').addEventListener('click', openModal);
      qs('#cancelReset').addEventListener('click', closeModal);
      qs('#confirmReset').addEventListener('click', ()=>{
        // soft reset (no reload), keeps fullscreen
        Object.assign(state, {
          selected: 1,
          scores: {1:0,2:0},
          currentBreak: {1:0,2:0},
          highBreak: {1:0,2:0},
          pending: 0,
          pendingBalls: [],
          pendingFor: 1,
          pendingFoul: false,
          redsLeft: 15,
          colorsRemaining: [...ALL_COLORS],
          history: [],
          redoStack: []
        });
        clearPending();
        selectPlayer(1);
        renderScores(); updateDiff(); updatePointsLeft(); renderBallVisibility(); save();
        closeModal();
      });

      // Fullscreen toggle
      qs('#fsBtn').addEventListener('click', ()=>{
        if(document.fullscreenElement){ document.exitFullscreen(); }
        else { document.documentElement.requestFullscreen(); }
      });

      // Select by clicking panel (except when clicking name contenteditable)
      qs('#p1').addEventListener('click', e=>{ if(!e.target.classList.contains('name')) selectPlayer(1); });
      qs('#p2').addEventListener('click', e=>{ if(!e.target.classList.contains('name')) selectPlayer(2); });

      // Init
      selectPlayer(state.selected);
      renderScores(); updateDiff(); updatePointsLeft(); renderBallVisibility();
      // Set initial FS label
      qs('#fsBtn').textContent = document.fullscreenElement ? 'ðŸ—— Exit Fullscreen' : 'â›¶ Fullscreen';
    })();
  </script>
</body>
</html>
